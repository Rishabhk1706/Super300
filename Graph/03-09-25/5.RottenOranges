https://www.geeksforgeeks.org/problems/rotten-oranges2536/1

class Solution {
    public boolean isValid(int[][] mat, boolean[][] visited,int x, int y, int n, int m){
        if(x>=0 && x<n && y>=0 && y<m && !visited[x][y] && mat[x][y]==1){
            return true;
        }
        return false;
    }
    public int bfs(int[][] mat, boolean[][] visited, Queue<int[]> q, int n, int m, int fresh){
        int maxtime=0;
        while(!q.isEmpty()){
            int[] cur = q.poll();
            int x = cur[0];
            int y = cur[1];
            int time = cur[2];
            if(mat[x][y]==1){
                fresh--;
            }
            maxtime = Math.max(maxtime,time);
            int[] dr = {0,1,0,-1};
            int[] dc = {1,0,-1,0};
            for(int i=0;i<4;i++){
                int nx = x+dr[i];
                int ny = y+dc[i];
                if(isValid(mat,visited,nx,ny,n,m)){
                    visited[nx][ny]=true;
                    q.add(new int[] {nx,ny,time+1});
                }
            }
        }
        if(fresh>0) return -1;
        return maxtime;
    }
    public int orangesRotting(int[][] mat) {
        int n=mat.length;
        int m=mat[0].length;
        Queue<int[]> q = new LinkedList<>();
        boolean[][] visited = new boolean[n][m];
        int fresh=0;
        int rotten=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(mat[i][j]==2){
                    q.add(new int[] {i,j,0});
                    rotten++;
                }
                if(mat[i][j]==1){
                    fresh++;
                }
            }
        }
        if(fresh==0) return 0;
        if(fresh!=0 && rotten==0) return -1;
        return bfs(mat,visited,q,n,m,fresh);
    }
}