https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/

class Pair{
    long nbr;
    long wt;
    public Pair(long nbr,long wt){
        this.nbr = nbr;
        this.wt = wt;
    }
}
class Solution {
    public int countPaths(int n, int[][] roads) {
        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();
        for(int i=0;i<n;i++){
            adj.add(new ArrayList<>());
        }
        for(int[] r : roads){
            int u = r[0];
            int v = r[1];
            int wt = r[2];
            adj.get(u).add(new Pair(v,wt));
            adj.get(v).add(new Pair(u,wt));
        }
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Long.compare(a.wt, b.wt));
        long[] dist = new long[n];
        long[] ways = new long[n];
        Arrays.fill(dist, Long.MAX_VALUE);
        dist[0] = 0;
        ways[0] = 1;
        pq.add(new Pair(0,0));
        long mod = (int) (1e9 + 7);
        while(pq.size()>0){
            Pair curr = pq.poll();
            long dis = curr.wt;
            long node = curr.nbr;
            if(dis > dist[(int) node]) continue;
            for(Pair pr : adj.get((int) node)){
                long nbr = pr.nbr;
                long wt = pr.wt;
                if(dis + wt < dist[(int) nbr]){
                    dist[(int) nbr] = dis + wt;
                    pq.add(new Pair(nbr,dist[(int) nbr]));
                    ways[(int) nbr] = ways[(int) node];
                }
                else if(dis + wt == dist[(int) nbr]){
                    ways[(int) nbr] = (ways[(int) nbr] + ways[(int) node])%mod;
                }
            }
        }
        return (int) (ways[n-1]%mod);
    }
}